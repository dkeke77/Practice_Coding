#include <iostream>
#include <string>
#include <vector>

using namespace std;

/*
    LCS 길이 찾는 문제
    이번엔 정석적으로 DP 이용해서 풀음

    두 문자열이 각각 행과 열로 이루어진 테이블을 만듦
    한 행에서 각 열에 해당하는 문자와 비교하면서 진행함
    비교하는 두 문자가 서로 다르다면 왼쪽 칸([i][j-1])과 위쪽 칸([i-1][j])중에서 더 큰 값을 계승함
    만약 같다면 왼쪽 대각선([i-1][j-1])에 1을 더하여 저장함
    이는 현재 문자 직전까지 LCS를 이용한다는 의미임
    왜냐하면 현재 문자 직전에 현재 문자를 붙이기 떄문에
    바로 위칸([i-1][j])을 이용한다면 이런 원리를 위배하는 것임

    단순히 LCS 길이를 알고 싶다면 dp 테이블의 제일 오른쪽 아래값을 출력하면 됨
    하지만 만약 진짜 LCS를 알고 싶다면 dp 테이블을 백트래킹해야됨
    이때도 행과 열의 문자를 비교하면 진행함
    비교하는 두 문자가 서로 다르다면 왼쪽 칸([i][j-1])과 위쪽 칸([i-1][j])중에서 더 큰 값이 있는 곳으로 이동함
    만약 두 문자가 서로 같다면 저장하고 왼쪽 대각선([i-1][j-1])으로 이동하면 됨
    그걸 테이블의 끝에 도달할때까지 진행하면 됨

    지금 작성한 코드에서는 LCS 길이만 찾으면 되기 때문에 DP 테이블을 압축했음
    2행짜리 2차원 배열이라서 만약 진짜 LCS를 알고 싶다면 테이블 크기를 늘려야됨
    아니면 GPT 말로는 경로 추적용 테이블을 써도 된다는데 정확히 뭔지 모르겠음
*/

int main()
{
    ios::sync_with_stdio(false);
	cin.tie(0);
    cout.tie(0);

    string s1,s2;
    cin >> s1 >> s2;
    vector<vector<int>> dp(2,vector<int>(s2.size()+1,0));

    for (int i=1; i<=s1.size(); i++)
    {
        for (int j=1; j<=s2.size(); j++)
        {
            if(s1[i-1]==s2[j-1])
                dp[i%2][j] = dp[(i-1)%2][j-1]+1;
            else
                dp[i%2][j] = max(dp[(i-1)%2][j],dp[i%2][j-1]);
        }
    }

    cout << dp[s1.size()%2].back();

    return 0;
}

/*
    문자열 A와 B...
    문자열 A를 기준으로 DP를 채운다
    011111
    111222
    122233
*/
